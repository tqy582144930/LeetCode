[toc]

# 链表

# 简单

## 合并两个链表

### 题目

将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

示例：

输入：1->2->4, 1->3->4
输出：1->1->2->3->4->4

### 题解

```c++
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        ListNode *preHead = new ListNode(-1);
        ListNode *pre = preHead;
        while (l1 != NULL && l2 != NULL) {
            if (l1->val <= l2->val) {
                pre->next = l1;
                l1 = l1->next;
            } else {
                pre->next = l2;
                l2 = l2->next;
            }
            pre = pre->next;
        }
        pre->next = l1 == NULL ? l2 : l1; 
        return preHead->next;
    }
};
```

### 总结

- 需要一个零时头节点，这样可以简化谁为第一个节点
- 需要一个pre节点，始终在当前节点前一个
- 谁先遍历完，另一个链表直接接在遍历完的后面

## 删除排序链表中的重复元素

### 题目

给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。

示例 1:

输入: 1->1->2
输出: 1->2
示例 2:

输入: 1->1->2->3->3
输出: 1->2->3

### 题解

```c++
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        ListNode *cur = head;
        while (cur != NULL && cur->next != NULL) {
            if (cur->val == cur->next->val) {
                ListNode *node = cur->next;
                cur->next = node->next;
                node = NULL;
            } else {
                cur = cur->next;
            }
        }
        return head;
    }
};
```

### 总结

- 在删除一个节点时，记得把这个节点置为空，不然会产生大量野指针

## 环形链表

### 题目

给定一个链表，判断链表中是否有环。

为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。

示例 1：

输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。


示例 2：

输入：head = [1,2], pos = 0
输出：true
解释：链表中有一个环，其尾部连接到第一个节点。


示例 3：

输入：head = [1], pos = -1
输出：false
解释：链表中没有环。

### 题解

```c++
class Solution {
public:
    bool hasCycle(ListNode *head) {
        if (head == NULL || head->next == NULL) {
            return false;
        }
        ListNode *fast = head->next, *slow = head;
        while(fast != slow) {
            if (fast == NULL || fast->next == NULL) {
                return false;
            }
            slow = slow->next;
            fast = fast->next->next;
        }
        return true;
    }
};
```

### 总结

- 最开始为什么要判断`head == NULL || head->next == NULL`,如果不这样，fast就不能复制为head->next

- 为什么`*fast = head->next, *slow = head;`，如果都设置为相同的起始节点，无法进入while循环
- 循环中返回条件为`fast == NULL || fast->next == NULL`,1. fast走的快，所以只用判断fast即可 2. 因为fast在赋值时会调用fast->next->next，如果不提前判断fast->next == NULL，有可能会指向野指针

## 链表相交

### 题解

```c++
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        if (headA == NULL || headB == NULL) {
            return NULL;
        }
        ListNode *pA = headA, *pB = headB;
        while (pA != pB) {
            pA = pA == NULL ? headB : pA->next;
            pB = pB == NULL ? headA : pB->next;
        }
        return pA;
    }
};
```

### 总结

- 两个相交链表无法保证一样长，所以需要把两个链表都走一遍，a+b=b+a
- 如果pA=pB就返回当前节点的位置，否则一直走到对方链表的末尾

## 移除链表元素

### 题目

删除链表中等于给定值 **val** 的所有节点。

**示例:**

```c++
输入: 1->2->6->3->4->5->6, val = 6
输出: 1->2->3->4->5
```

### 题解

```c++
// 没有考虑内存
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        ListNode *preHead = new ListNode(-1);
        preHead->next = head;
        ListNode *ptr = preHead;
        while(ptr->next != NULL)
        {
            if(ptr->next->val == val)
            {
                ptr->next = ptr->next->next;
            }
            else
            {
                ptr = ptr->next;
            }
        }
        return preHead->next;
    }
};

// 考虑了内存
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        ListNode *preHead = new ListNode(-1);
        preHead->next = head;
        ListNode *ptr = preHead, *toDelete = nullptr;
        while(ptr->next != NULL)
        {
            if(ptr->next->val == val)
            {
                toDelete = ptr->next;
                ptr->next = ptr->next->next;
            } else {
                ptr = ptr->next;
            }
            if (toDelete != nullptr) {
                delete toDelete;
                toDelete = nullptr;
            }
        }
        ListNode *ret = preHead->next;
        delete preHead;
        return ret;
    }
};
```

### 总结

- 哨兵节点广泛应用于树和链表中，如伪头、伪尾、标记等，它们是纯功能的，通常不保存任何数据，其主要目的是使链表标准化，如使**链表永不为空、永不无头、简化插入和删除。**
- 如果是简单的指针变换，没有考虑内存的消耗，需要释放删除掉的ListNode

## 返回倒数第k个节点

### 题目

实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。

注意：本题相对原题稍作改动

```
示例：
输入： 1->2->3->4->5 和 k = 2
输出： 4
说明：
给定的 k 保证是有效的。
```

### 题解

```c++
class Solution {
public:
    int kthToLast(ListNode* head, int k) {
        ListNode *fast = head, *slow = head;
        while(k > 0) {
            fast = fast->next;
            k--;
        }
        while(fast != NULL) {
            fast = fast->next;
            slow = slow->next;
        }
        return slow->val;
    }
};
```

### 总结

- 标准题型，使用快慢指针，快指针先移动k个位置，然后再同时移动，直到快指针指向null，这个时候慢指针就指向倒数第k个元素

## 二进制链表转整数

### 题目

给你一个单链表的引用结点 head。链表中每个结点的值不是 0 就是 1。已知此链表是一个整数数字的二进制表示形式。

请你返回该链表所表示数字的 十进制值 。

示例 1：

输入：head = [1,0,1]
输出：5
解释：二进制数 (101) 转化为十进制数 (5)
示例 2：

输入：head = [0]
输出：0
示例 3：

输入：head = [1]
输出：1
示例 4：

输入：head = [1,0,0,1,0,0,1,1,1,0,0,0,0,0,0]
输出：18880
示例 5：

输入：head = [0,0]
输出：0


提示：

链表不为空。
链表的结点总数不超过 30。
每个结点的值不是 0 就是 1。

### 题解

```c++
class Solution {
public:
    int getDecimalValue(ListNode* head) {
        ListNode *cur = head;
        int result = 0;
        while (cur != NULL) {
          	// 这里操作相当于算数左移的操作
            result = 2*result + cur->val;
            cur = cur->next;
        }
        return result;
    }
};
```

### 总结

- 了解二进制转十进制过程，为什么需要✖️2

## 链表中倒数第k个节点

### 题目

输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。

示例：

给定一个链表: 1->2->3->4->5, 和 k = 2.

返回链表 4->5.

### 题解

```c++
class Solution {
public:
    ListNode* getKthFromEnd(ListNode* head, int k) {
        ListNode *fast = head, *slow = head;
        while (k > 0) {
          	if (fast == NULL) {
            	return NULL;
            }
            fast = fast->next;
            k--;
        }
        while (fast != NULL) {
            fast = fast->next;
            slow = slow->next;
        }
        return slow;
    }
};
```

### 总结

- 使用双指针移动，这里需要考虑到k比链表长的条件，还有head为空的条件

## 反转链表

### 题目

反转一个单链表。

示例:

输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL
进阶:
你可以迭代或递归地反转链表。你能否用两种方法解决这道题？

### 题解

```c++
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode *pre = NULL, *cur = head, *next = NULL;
        while (cur != NULL) {
            next = cur->next;
            cur->next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
};
```

### 总结

- 反转链表，目的就是将节点的next指向前驱，但当前节点无法访问过去节点，所以需要一个pre保存前驱节点
- 由于我们需要将当前节点的next指向前驱，如果不保存当前节点的下一节点 ，这样就会丢失后面链表，所以需要 next保存后继节点
- 反转流程：
  1. 用next来保存cur节点的后继
  2. 将cur的next指向前驱pre
  3. 把pre移动至cur节点，当作下一次反转的前驱
  4. 把cur移动到next，也就是cur节点的后继

## 删除链表的节点

### 题目

给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。

返回删除后的链表的头节点。

注意：此题对比原题有改动

示例 1:

输入: head = [4,5,1,9], val = 5
输出: [4,1,9]
解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.
示例 2:

输入: head = [4,5,1,9], val = 1
输出: [4,5,9]
解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 5 -> 9.

### 题解

```c++
class Solution {
public:
    ListNode* deleteNode(ListNode* head, int val) {
        if (head == NULL) {
            return NULL;
        }
      	// 如果头节点就是需要删除节点，直接返回head->next
        if (head->val == val) {
            return head->next;
        }
        ListNode *pre = head, *cur = head->next;
        while (cur->val != val && cur != NULL) {
            pre = cur;
            cur = cur->next;
        }
      	// 如果cur==NULL，说明链表中没有删除的节点，直接返回该链表
      	// 如果cur!=NULL，删除链表
        if (cur != NULL) {
            pre->next = cur->next;
        }
        return  head;
    }
};
```

### 总结

- 删除链表类题型，需要注意删除为头节点的判断，两种处理方式
  1. 添加一个头节点
  2. 对头节点进行单独判断

- 需要判断链表中是否含有该节点，如果没有则不删除，否则进行删除
- 删除节点后，需要free掉删除对象

## 两个链表的第一个公共节点

### 题目

编写一个程序，找到两个单链表相交的起始节点。

### 题解

```c++
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        if (headA == NULL || headB == NULL) {
            return NULL;
        }
        ListNode *pA = headA, *pB = headB;
        while (pA != pB) {
            pA = pA == NULL ? headB : pA->next;
            pB = pB == NULL ? headA : pB->next;
        }
        return pA;
    }
};
```

### 总结

- 这里使用了非常巧妙的把两个链表都走一遍的方式，消除了链表的长度差

## 移除重复节点

###  题目

编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。

示例1:

 输入：[1, 2, 3, 3, 2, 1]
 输出：[1, 2, 3]
示例2:

 输入：[1, 1, 1, 1, 2]
 输出：[1, 2]

### 题解

```c++
class Solution {
public:
    ListNode* removeDuplicateNodes(ListNode* head) {
        if (head == NULL) {
            return head;
        }
        ListNode *p = head;
        unordered_set<int> set;	// 底层是一个哈希表
        set.insert(p->val);
        while (p->next != NULL) {
            if (set.count(p->next->val)) {// 如果该元素的数量不为0，则重复，删除
                p->next = p->next->next;
            } else {// 否则进行插入，然后对下一个进行比较
                set.insert(p->next->val);
                p = p->next;
            }
        }
        return head;
    }
};
```

### 总结

- 需要借助哈希表这个容器，来进行判断有几个该元素

## 链表的中间节点

### 题目

给定一个带有头结点 head 的非空单链表，返回链表的中间结点。

如果有两个中间结点，则返回第二个中间结点。

示例 1：

输入：[1,2,3,4,5]
输出：此列表中的结点 3 (序列化形式：[3,4,5])
返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。
注意，我们返回了一个 ListNode 类型的对象 ans，这样：
ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.
示例 2：

输入：[1,2,3,4,5,6]
输出：此列表中的结点 4 (序列化形式：[4,5,6])
由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。

### 题解

```c++
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        if (head == NULL) {
            return NULL;
        }
        ListNode *fast = head, *slow = head;
        while (fast != NULL && fast->next != NULL) {// 注意这里判断条件
            slow = slow->next;
            fast = fast->next->next;
        }
        return slow;
    }
};
```

### 总结

- 这里需要注意判断条件，面试过程中需要画两条奇数和偶数链表测试，就可以的出边界条件

## 回文链表

### 题目

编写一个函数，检查输入的链表是否是回文的。

**示例 1：**

```
输入： 1->2
输出： false 
```

**示例 2：**

```
输入： 1->2->2->1
输出： true 
```

### 题解

```c++
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        if (head == NULL || head->next == NULL) {
            return true;
        }
        ListNode *midNode = endOfFirstHalf(head);
      	// 如果是奇数链表，从中间节点后一个节点开始反转
        ListNode *secondeHalfStart = reverseList(midNode->next);

        ListNode *first = head;
        ListNode *seconde = secondeHalfStart;
      	// 反转条件是后半段链表指向NULL
        while (seconde != NULL) {
            if (first->val != seconde->val) {
                return false;
            }
            first = first->next;
            seconde = seconde->next;
        }
        midNode->next = reverseList(secondeHalfStart);
        return true;
    }

    private: ListNode* reverseList(ListNode* head) {
        ListNode *pre = NULL, *cur = head;
        while (cur != NULL) {
            ListNode *next = cur->next;
            cur->next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }

    private: ListNode* endOfFirstHalf(ListNode* head) {
        ListNode *fast = head, *slow = head;
      	// 这里寻找中点，如果是偶数，返回前面那个
        while (fast != NULL && fast->next != NULL && fast->next->next != NULL) {
            fast = fast->next->next;
            slow = slow->next;
        }
        return slow;
    }
};
```

### 总结

- 查找链表中间的节点
  1. 偶数链表，返回第一个节点
  2. 偶数链表，返回第二个节点
  3. 区别是第一个返回方式，判断条件添加fast->next->next != NULL

- 这里需要使用偶数链表返回第一个节点，原因
  - 因为如果是个奇数链表，判断是否是回文链表不需要判断中间那个元素，只要两边对称中间为任何都可以，所以此时需要反转后半段链表，需要从中间节点之后的第一个节点开始反转，然而边界判断条件是根据反转链表的是否到达NULL，如果使用返回第二个节点方式，后半段会长于前半段，所以循环边界条件不正确。

# 中等

## 两数相加

### 题目

给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。

如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。

您可以假设除了数字 0 之外，这两个数都不会以 0 开头。

**示例：**

```c++
输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)
输出：7 -> 0 -> 8
原因：342 + 465 = 807
```

### 题解

```c++
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode *newHead = new ListNode(0);
        ListNode *p1 = l1, *p2 = l2, *cur = newHead;
        int carray = 0;
        while (p1 != NULL || p2 != NULL) {
            int x = (p1 == NULL ? 0 : p1->val); // 如果到达NULL，之后x就为0
            int y = (p2 == NULL ? 0 : p2->val);
            int sum = carray + x + y;	// 每次相加都需要加上carray
            carray = sum / 10;
            cur->next = new ListNode(sum % 10);
            cur = cur->next;
            if (p1 != NULL) {	// 如果已经指向空了，就不再走下一步，否则会崩溃
                p1 = p1->next;
            }
            if (p2 != NULL) {
                p2 = p2->next;
            }
        }
        if (carray > 0) { // 如果计算完成，最后carray是大于0，说明还需要进位一次，因为十进制相加，进位肯定为1
            cur ->next = new ListNode(1);
        }
        return newHead->next;
    }
};
```

### 总结

- 将当前结点初始化为返回列表的哑结点。
- 将进位 carry 初始化为 0。
- 将 pp 和 qq 分别初始化为列表 l1和 l2的头部。
- 遍历列表 l1 和 l2 直至到达它们的尾端。
  - 将 x 设为结点 p 的值。如果 pp 已经到达 l1的末尾，则将其值设置为 0。
  - 将 y 设为结点 q 的值。如果 qq 已经到达 l2的末尾，则将其值设置为 0。
  - 设定 sum = x + y + carry。
  - 更新进位的值，carry = sum / 10。
  - 创建一个数值为 (sum % 10) 的新结点，并将其设置为当前结点的下一个结点，然后将当前结点前进到下一个结点。
  - 同时，将 p 和 q 前进到下一个结点。
- 检查 carry = 1是否成立，如果成立，则向返回列表追加一个含有数字 1 的新结点。
- 返回哑结点的下一个结点。

## 复制带随机指针的链表

### 题目

给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。

要求返回这个链表的 **[深拷贝](https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin)**。 

我们用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：

- val：一个表示 Node.val 的整数。
- random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为  null 。

```c++
输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]
```

### 题解

```c++
class Solution {
public:
    Node* copyRandomList(Node* head) {
        if (head == NULL) {
            return head;
        }
        Node *cur = head;
        while (cur != NULL) {
          	// 这里只复制了就节点的next指针，不复制random
          	// 我们需要新节点的random指向新复制的节点，不是指向的旧的节点
            Node *newNode = new Node(cur->val);
            newNode->next = cur->next;
            cur->next = newNode;
            cur = newNode->next;
        }
        cur = head;
        while (cur != NULL) {
          	// 这里需要注意：如果新节点的random指向，需要通过旧节点random来更新
          	// 如果旧节点的random指向null，新节点直接指向null
          	// 否则，通过cur->random->next找到该节点
          	// 如果直接赋值为cur->next->random = cur->random->next,如果cur->random本来就是null，访问next会崩溃
            cur->next->random = (cur->random != NULL) ? cur->random->next : NULL;
            cur = cur->next->next;
        }
        Node *oldHead = head;
        Node *newHead = head->next;
        Node *result = head->next;
        while (oldHead != NULL) {
            oldHead->next = oldHead->next->next;
          	// 这里需要注意，一个链表只有一个NULL尾节点，所以我们需要向新链表添加一个指向NULL的尾节点
            newHead->next = (newHead->next != NULL) ? newHead->next->next : NULL;
            oldHead = oldHead->next;
            newHead = newHead->next;
        }
        return result;
    }
};
```

### 总结

- 第一步复制所有节点，形成新旧节点交替效果
- 遍历该链表，通过旧节点的random更新新节点的random指向
- 拆分新旧两个链表

## 环形链表II

### 题目

给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。

为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。

说明：不允许修改给定的链表。

```c++
示例1：

输入：head = [3,2,0,-4], pos = 1
输出：tail connects to node index 1
解释：链表中有一个环，其尾部连接到第二个节点。
```

### 题解

```c++
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        if(head == NULL) {
            return NULL;
        }
        ListNode *fast = head, *slow = head;
        while (true) {
            if (fast == NULL || fast->next == NULL) {
                return NULL;
            }
            fast = fast->next->next;
            slow = slow->next;
            if (fast == slow) {
                break;
            }
        }
        fast = head;
        while (fast != slow) {
            fast = fast->next;
            slow = slow->next;
        }
        return slow;
    }
};
```

### 总结

- https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/linked-list-cycle-ii-kuai-man-zhi-zhen-shuang-zhi-/

## 重排链表

### 题目

给定一个单链表 L：L0→L1→…→Ln-1→Ln ，
将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…

你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

```c++
示例 1:

给定链表 1->2->3->4, 重新排列为 1->4->2->3.
```

```c++
示例 2:

给定链表 1->2->3->4->5, 重新排列为 1->5->2->4->3.
```

### 题解

```c++
class Solution {
public:
    void reorderList(ListNode* head) {
        if (head == NULL) {
            return;
        }
        ListNode *fast = head, *slow = head;
        while (fast != NULL && fast->next != NULL) {
            slow = slow->next;
            fast = fast->next->next;
        }
        ListNode *newHead = slow->next;
        slow->next = NULL;

        newHead = revertList(newHead);
        while (newHead != NULL) {
            ListNode *temp = newHead->next;
            newHead->next = head->next;
            head->next = newHead;
            head = newHead->next;
            newHead = temp;
        }
    }

    ListNode *revertList(ListNode *head) {
        if (head == NULL) {
            return NULL;
        }
        ListNode *pre = NULL, *cur = head;
        while (cur != NULL) {
            ListNode *next = cur->next;
            cur->next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
};
```

### 总结

```c++
1 -> 2 -> 3 -> 4 -> 5 -> 6
第一步，将链表平均分成两半
1 -> 2 -> 3
4 -> 5 -> 6
    
第二步，将第二个链表逆序
1 -> 2 -> 3
6 -> 5 -> 4
    
第三步，依次连接两个链表
1 -> 6 -> 2 -> 5 -> 3 -> 4
```

- 快指针一次走两步，慢指针一次走一步，当快指针走到终点的话，慢指针会刚好到中点。如果节点个数是偶数的话，slow 走到的是左端点，利用这一点，我们可以把奇数和偶数的情况合并，不需要分开考虑。

- 注意链表的合并

## 链表中的下一个更大节点

### 题目

给出一个以头节点 head 作为第一个节点的链表。链表中的节点分别编号为：node_1, node_2, node_3, ... 。

每个节点都可能有下一个更大值（next larger value）：对于 node_i，如果其 next_larger(node_i) 是 node_j.val，那么就有 j > i 且  node_j.val > node_i.val，而 j 是可能的选项中最小的那个。如果不存在这样的 j，那么下一个更大值为 0 。

返回整数答案数组 answer，其中 answer[i] = next_larger(node_{i+1}) 。

注意：在下面的示例中，诸如 [2,1,5] 这样的输入（不是输出）是链表的序列化表示，其头节点的值为 2，第二个节点值为 1，第三个节点值为 5 。

```c++
示例 1：

输入：[2,1,5]
输出：[5,5,0]

示例 2：

输入：[2,7,4,3,5]
输出：[7,0,5,5,0]

示例 3：

输入：[1,7,5,1,9,2,5,1]
输出：[7,9,9,9,0,5,0,0]
```

### 题解

```c++
class Solution {
public:
    vector<int> nextLargerNodes(ListNode* head) {
        if (head == NULL) {
            return vector<int>();
        }

        vector<int> res;
        int index = 0;
        stack<pair<int, int>> stack; // first为val，seconde为index
        while (head) {
            res.push_back(0); // 给res数组添加一个0，1.保证长度 2.后面无更大的值的话为0
          	// 栈不为空，且head指向的val大于栈顶的元素的值
            while (!stack.empty() && head->val > stack.top().first) {
                res[stack.top().second] = head->val;
                stack.pop();
            }
            stack.push(make_pair(head->val, index++));
            head = head->next;
        }
        return res;
    }
};
```

### 总结

- **单调栈**

## 删除链表倒数第N个节点

### 题目

给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。

```c++
示例：

给定一个链表: 1->2->3->4->5, 和 n = 2.

当删除了倒数第二个节点后，链表变为 1->2->3->5.
```


说明：

给定的 n 保证是有效的。

### 题解

```c++
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode *newHead = new ListNode(0);
        newHead->next = head;
        ListNode *fast = newHead, *slow = newHead;
        while (n > 0) {
            fast = fast->next;
            n--;
        }
        while (fast->next != NULL) {
            fast = fast->next;
            slow = slow->next;
        }
        slow->next = slow->next->next;
        return newHead->next;
    }
};
```

### 总结

- 删除链表类题型，需要注意删除为头节点的判断，两种处理方式
  1. 添加一个头节点
  2. 对头节点进行单独判断

- 本题目不知道链表的长度，所以没有办法通过n知道删除的是否是第一个节点，所有只能通过添加头节点的方式来避免此问题

## 对链表进行插入排序

### 题目

对链表进行插入排序。

**示例 1：**

```c++
输入: 4->2->1->3
输出: 1->2->3->4
```

### 题解

```c++
class Solution {
public:
    ListNode* insertionSortList(ListNode* head) {
        if (head == NULL || head->next == NULL) {
            return head;
        }
        ListNode *newHead = new ListNode(0);
        ListNode *cur = NULL, *pre = newHead, *node = head;
        while (node != NULL) {
            cur = node;
            node = node->next;
            if (cur->val < pre->val) {
                pre = newHead;
            }
            while (pre->next != NULL && cur->val > pre->next->val) {
                pre = pre->next;
            }

            cur->next = pre->next;
            pre->next = cur;
        }
        return newHead->next;
    }
};
```

### 总结

- 掌握插入排序
- 因为插入的元素有可能是头节点，所以需要构造一个哨兵节点来永远指向头节点
- 可以利用前一个插入的位置进行提速，即每次先把当前要插入的元素和前一个插入点比较，如果比它大，那么就从这里开始搜索，否则才需要从链表头开始搜索

## 排序链表

### 题目

### 题解

### 总结

## 两两交换链表中的节点

### 题目

给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。

你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

```c++
示例:

给定 1->2->3->4, 你应该返回 2->1->4->3.
```

### 题解

```c++
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if (head == NULL) {
            return NULL;
        }
        ListNode *newHead = new ListNode(0); // 需要动头节点，所以需要构建一个哑节点
        newHead->next = head;
        ListNode *pre = newHead;
        while (pre->next != NULL && pre->next->next != NULL) { // 因为需要遍历pre后面两个节点，所以需要判断两个节点都不为空
            ListNode *first = pre->next;
            ListNode *second = pre->next->next;
						
          	// 进行交换
            pre->next = second;
            first->next = second->next;
            second->next = first;
          	// 更新下一个前继节点
            pre = first;
        }
        return newHead->next;
    }
};
```

### 总结

- 每次需要指向两个节点，然后进行交换两个节点，接着更新下一个前继节点

## 分割链表

### 题目

编写程序以 x 为基准分割链表，使得所有小于 x 的节点排在大于或等于 x 的节点之前。如果链表中包含 x，x 只需出现在小于 x 的元素之后(如下所示)。分割元素 x 只需处于“右半部分”即可，其不需要被置于左右两部分之间。

```c++
示例:

输入: head = 3->5->8->5->10->2->1, x = 5
输出: 3->1->2->10->5->5->8
```

### 题解

```c++
class Solution {
public:
    ListNode* partition(ListNode* head, int x) {
        if (head == NULL) {
            return NULL;
        }
        ListNode *newHead = new ListNode(0);
        newHead->next = head;
        ListNode *pre = head, *cur = head->next;
        while (cur != NULL) {
            if (cur->val < x) {
                pre->next = cur->next;
              	// 这里本来写的是 cur->next = pre;最后报错了，因为是头插，所以每次插入都在头节点的后面，但是pre会不断的向后移
              	// 所以写成pre出错，正确应该是写在newHead->next后面
                cur->next = newHead->next; 
                newHead->next = cur;
                cur = pre->next;
            } else {
                cur = cur->next;
                pre = pre->next;
            }
        }
        return newHead->next;
    }
};
```

### 总结

- 了解链表的头插法
- 链表的头插法需要动头节点，所以构造一个亚节点有利于操作

## 链表的组件

### 题目

给定一个链表（链表结点包含一个整型值）的头结点 head。

同时给定列表 G，该列表是上述链表中整型值的一个子集。

返回列表 G 中组件的个数，这里对组件的定义为：链表中一段最长连续结点的值（该值必须在列表 G 中）构成的集合。

```c++
示例 1：

输入: 
head: 0->1->2->3
G = [0, 1, 3]
输出: 2
解释: 
链表中,0 和 1 是相连接的，且 G 中不包含 2，所以 [0, 1] 是 G 的一个组件，同理 [3] 也是一个组件，故返回 2。

示例 2：

输入: 
head: 0->1->2->3->4
G = [0, 3, 1, 4]
输出: 2
解释: 
链表中，0 和 1 是相连接的，3 和 4 是相连接的，所以 [0, 1] 和 [3, 4] 是两个组件，故返回 2。
```

### 题解

```c++
class Solution {
public:
    int numComponents(ListNode* head, vector<int>& G) {
        if (head == NULL) {
            return 0;
        }
        set<int> s;
        for (int i = 0; i < G.size(); i++) {
            s.insert(G[i]);
        }
        ListNode *cur = head;
        int ans = 0;
        while (cur != NULL) {
            if (s.count(cur->val) && 
            (cur->next == NULL || !s.count(cur->next->val))) {
                ans++;
            }
            cur = cur->next;
        }
        return ans;
    }
};
```

### 总结

- 首先把数组中的元素插入到哈希表中，方便查找；
- 然后遍历链表，如果链表的该元素可以在哈希表中查询到，先继续查询下一个，如果当前元素是最后一个，数量就加一

- 注意：因此如果当前的节点在列表 `G` 中，并且下一个节点不在列表 `G` 中，我们就找到了一个组件的尾节点

## 设计链表

### 题目

设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。

在链表类中实现这些功能：

get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。
addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。
addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。
addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。
deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。

```c++
示例：

MyLinkedList linkedList = new MyLinkedList();
linkedList.addAtHead(1);
linkedList.addAtTail(3);
linkedList.addAtIndex(1,2);   //链表变为1-> 2-> 3
linkedList.get(1);            //返回2
linkedList.deleteAtIndex(1);  //现在链表是1-> 3
linkedList.get(1);            //返回3
```

### 题解

```c++
class MyLinkedList {
public:
    struct ListNode {
        int val;
        ListNode *next;
        ListNode(int x): val(x), next(NULL) {};
    };

    int len;
    ListNode *head = NULL;

    MyLinkedList() {
        len = 0;
        head = new ListNode(0);
    }
    
    int get(int index) {
        if (index < 0 || index >= len) {
            return -1;
        }
        ListNode *cur = head;
        while (index >= 0) {
            cur = cur->next;
            index--;
        }
        return cur->val;
    }
    
    void addAtHead(int val) {
        addAtIndex(0, val);
    }
    
    void addAtTail(int val) {
        addAtIndex(len, val);
    }
    
    void addAtIndex(int index, int val) {
        if (index > len) {
            return;
        }
        if (index < 0) {
            index = 0;
        }
        len++;
        ListNode *pre = head, *cur = head->next;
        while (index > 0) {
            pre = pre->next;
            cur = (cur == NULL ? NULL : cur->next);
            index--;
        }
        ListNode *node = new ListNode(val);
        pre->next = node;
        node->next = cur;
    }
    
    void deleteAtIndex(int index) {
        if (index < 0 || index >= len) {
            return;
        }
        len--;
        ListNode *pre = head, *cur = head->next;
        while (index > 0) {
            pre = pre->next;
            cur = (cur == NULL ? NULL : cur->next);
            index--;
        }
        pre->next = cur->next;
    }
};
```

### 总结

- 注意题目中index是从0开始还是从1开始
- 如果是从0开始，那么index>=len就说明已经指向空了，就需要返回
- 如果需要提高尾插的效率，可以引入tail节点

## 两数相加II

### 题目

给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。

你可以假设除了数字 0 之外，这两个数字都不会以零开头。

 

进阶：

如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。

```c++
示例：

输入：(7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4)
输出：7 -> 8 -> 0 -> 7
```

### 题解

```c++
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        if (l1 == NULL || l2 == NULL) {
            return NULL;
        }
        stack<int> s1, s2;
        while (l1) {
            s1.push(l1->val);
            l1 = l1->next;
        }
        while(l2) {
            s2.push(l2->val);
            l2 = l2->next;
        }
        int carray = 0;
        ListNode *cur = NULL;
        while (!s1.empty() || !s2.empty() || carray > 0) {
            int x = s1.empty() ? 0 : s1.top();
            int y = s2.empty() ? 0 : s2.top();
            if (!s1.empty()) s1.pop();
            if (!s2.empty()) s2.pop();
            int sum = carray + x + y;
            carray = sum / 10;
            ListNode *node = new ListNode(sum % 10);
            node->next = cur;
            cur = node;
        }
        return cur;
    }
};
```

### 总结

- 由于题中要求不能破坏链表结构，所以不能使用先反转再相加的方式
- **想要反转万能方法栈**
- 注意这里计算出来的东西使用头节点的插入方法

## 二叉树中的列表

### 题目

给你一棵以 root 为根的二叉树和一个 head 为第一个节点的链表。

如果在二叉树中，存在一条一直向下的路径，且每个点的数值恰好一一对应以 head 为首的链表中每个节点的值，那么请你返回 True ，否则返回 False 。

一直向下的路径的意思是：从树中某个节点开始，一直连续向下的路径。

```c++
输入：head = [4,2,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]
输出：true
解释：树中蓝色的节点构成了与链表对应的子路径。
```

### 题解

```c++
class Solution {
    bool dfs(TreeNode *rt, ListNode *head) {
      	// 链表已经全部匹配完，匹配成功
        if (head == NULL) {
            return true;
        }
      	// 二叉树访问到了空节点，匹配失败
        if (rt == NULL) {
            return false;
        }
     		// 当前匹配的二叉树上节点的值与链表节点的值不相等，匹配失败
        if (rt->val != head->val) {
            return false;
        }
        return dfs(rt->left, head->next) || dfs(rt->right, head->next);
    }
public:
    bool isSubPath(ListNode* head, TreeNode* root) {
        if (root == NULL) {
            return false;
        }
        return dfs(root, head) || isSubPath(head, root->left) || isSubPath(head, root->right);
    }
};
```

### 总结

- 枚举二叉树中的每个节点为起点往下的路径是否有与链表相匹配的路径。为了判断是否匹配我们设计一个递归函数 dfs(rt ,head) ，其中 rtrt 表示当前匹配到的二叉树节点，head 表示当前匹配到的链表节点，整个函数返回布尔值表示是否有一条该节点往下的路径与 head 节点开始的链表匹配，如匹配返回 true，否则返回 false ，一共有四种情况：

  1. 链表已经全部匹配完，匹配成功，返回 true

  2. 二叉树访问到了空节点，匹配失败，返回 false

  3. 当前匹配的二叉树上节点的值与链表节点的值不相等，匹配失败，返回false

  4. 前三种情况都不满足，说明匹配成功了一部分，我们需要继续递归匹配，所以先调用函数 dfs(rt→left,head→next) ，其中 rt→left 表示该节点的左儿子节点，head→next 表示下一个链表节点，如果返回的结果是false，说明没有找到相匹配的路径，需要继续在右子树中匹配，继续递归调用函数dfs(rt→right,head→next) 去找是否有相匹配的路径，其中rt→right 表示该节点的右儿子节点，head→next 表示下一个链表节点。

- 匹配函数确定了，剩下只要枚举即可，从根节点开始，如果当前节点匹配成功就直接返回 true ，否则继续找它的左儿子和右儿子是否满足，也就是代码中的 `dfs(root,head) || isSubPath(head,root->left) || isSubPath(head,root->right)` ，然后不断的递归调用。这样枚举所有节点去判断即能找出是否有一条与链表相匹配的路径。

## 旋转链表

### 题目

给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。

```c++
示例 1:

输入: 1->2->3->4->5->NULL, k = 2
输出: 4->5->1->2->3->NULL
解释:
向右旋转 1 步: 5->1->2->3->4->NULL
向右旋转 2 步: 4->5->1->2->3->NULL
示例 2:

输入: 0->1->2->NULL, k = 4
输出: 2->0->1->NULL
解释:
向右旋转 1 步: 2->0->1->NULL
向右旋转 2 步: 1->2->0->NULL
向右旋转 3 步: 0->1->2->NULL
向右旋转 4 步: 2->0->1->NULL
```

### 题解

```c++
class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {
        if (head == NULL) {
            return NULL;
        }
        if (head->next == NULL) {
            return head;
        }
        int len = 1;
        ListNode *cur = head;
        while (cur->next != NULL) {
            cur = cur->next;
            len++;
        }
        cur->next = head;

        ListNode *newTail = head;
        for (int i = 0; i < len - k % len - 1; i++) {
            newTail = newTail->next;
        }
        ListNode *newHead = newTail->next;
        newTail->next = NULL;
        return newHead;
    }
};
```

### 总结

- 找到旧的尾部并将其与链表头相连 old_tail.next = head，整个链表闭合成环，同时计算出链表的长度 n。
- 找到新的尾部，第 (n - k % n - 1) 个节点 ，新的链表头是第 (n - k % n) 个节点。
- 断开环 new_tail.next = None，并返回新的链表头 new_head

## 分割链表

### 题目

给定一个头结点为 root 的链表, 编写一个函数以将链表分隔为 k 个连续的部分。

每部分的长度应该尽可能的相等: 任意两部分的长度差距不能超过 1，也就是说可能有些部分为 null。

这k个部分应该按照在链表中出现的顺序进行输出，并且排在前面的部分的长度应该大于或等于后面的长度。

返回一个符合上述规则的链表的列表。

举例： 1->2->3->4, k = 5 // 5 结果 [ [1], [2], [3], [4], null ]

```c++
示例 1：

输入: 
root = [1, 2, 3], k = 5
输出: [[1],[2],[3],[],[]]
解释:
输入输出各部分都应该是链表，而不是数组。
例如, 输入的结点 root 的 val= 1, root.next.val = 2, \root.next.next.val = 3, 且 root.next.next.next = null。
第一个输出 output[0] 是 output[0].val = 1, output[0].next = null。
最后一个元素 output[4] 为 null, 它代表了最后一个部分为空链表。
```

### 题解

```c++
class Solution {
public:
    vector<ListNode*> splitListToParts(ListNode* root, int k) {
        int len = 0;
        ListNode *cur = root;
        while (cur != NULL) {
            cur = cur->next;
            len++;
        }
        int width = len / k, rem = len % k;
        vector<ListNode *> ve(k, NULL);
        cur = root;
        for (int i = 0; i < k; i++) {
            ListNode *head = cur;
            for (int j = 0; j < width + (rem > i ? 1 : 0) - 1; j++) {
                if (cur != NULL) {
                    cur = cur->next;
                }
            }
            if (cur != NULL) {
                ListNode *pre = cur;
                cur = cur->next;
                pre->next = NULL;
            }
            ve[i] = head;
        }
        return ve;
    }
};
```

### 总结

- 先计算链表的长度N
- 然后计算出每组链表的宽度n/k，计算出多出来的节点n%k；
- 题目要求每组之间不能超过1，并且多的组在前面，所以n%k个组的元素个数比k多1
- 避免多构造链表，直接拆分该链表即可。
- for循环便利链表时，要小于len-1。遍历链表是从0开始的。

## 奇偶链表

### 题目

给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。

请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。

```c++
示例 1:

输入: 1->2->3->4->5->NULL
输出: 1->3->5->2->4->NULL
示例 2:

输入: 2->1->3->5->6->4->7->NULL 
输出: 2->3->6->7->1->5->4->NULL
```

### 题解

```c++
class Solution {
public:
    ListNode* oddEvenList(ListNode* head) {
        if (head == NULL) {
            return head;
        }
        ListNode *old = head, *evenHead = head->next, *even = head->next;
        while (even != NULL && even->next != NULL) {
            old->next = even->next;
            old = old->next;
            even->next = even->next->next;
            even = even->next;
        }
        old->next = evenHead;
        return head;
    }
};
```

### 总结

- 先把链表分成奇偶两个链表，然后把偶链表拼接到奇链表的后面。

## 复杂链表的复制

### 题目

请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。

```c++
输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]
```

### 题解

```c++
class Solution {
public:
    Node* copyRandomList(Node* head) {
        if (head == NULL) {
            return NULL;
        }
        Node *cur = head;
        while (cur != NULL) {
            Node *node = new Node(cur->val);
            node->next = cur->next;
            cur->next = node;
            cur = node->next;
        }
        cur = head;
        while (cur != NULL) {
            cur->next->random = cur->random == NULL ? NULL : cur->random->next;
            cur = cur->next->next;
        }
        Node *oldHead = head, *newHead = head->next, *result = head->next;
        while (oldHead != NULL) {
            oldHead->next = oldHead->next->next;
            newHead->next = (newHead->next != NULL) ? newHead->next->next : NULL;
            oldHead = oldHead->next;
            newHead = newHead->next;
        }
        return result;
    }
};
```

### 总结

- 先复制原有节点，新复制节点放置在原节点之后
- 然后通过原节点给新节点的random指针复制
- 然后拆分两个链表
  - 拆分两个链表需要两个指针指向分别的头节点，需要两个指针进行向后迭代
  - 指向头节点保证不动，两个指针按要求向后拆分链表

## 删除排序链表中的重复元素II

### 题目

给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。

```c++
示例 1:

输入: 1->2->3->3->4->4->5
输出: 1->2->5
示例 2:

输入: 1->1->1->2->3
输出: 2->3
```

### 题解

```c++
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if (head == NULL) {
            return head;
        }
        ListNode *newHead = new ListNode(0);
        newHead->next = head;
        ListNode *cur = newHead;
        while (cur->next != NULL && cur->next->next != NULL) {
            if (cur->next->val == cur->next->next->val) {
                ListNode *temp = cur->next;
                while (temp != NULL && temp->next != NULL && temp->val == temp->next->val) {
                    temp = temp->next;
                }
                cur->next = temp->next;
            } else {
                cur = cur->next;
            }
        }
        return newHead->next;
    }
};
```

### 总结

- 涉及到删除链表，需要构造头节点，方便删除第一个节点
- 因为要对比cur(cur最初始的定义指向空结点)指针的下一个结点与下下一个结点的值是否相等，为了防止产生空指针异常，故退出迭代的条件为：cur.next != null && cur.next.next != null。
- 如果cur.next.val == cur.next.next.val说明此时有重复元素，此时创建一个临时指针temp，指向cur的下一个节点，即temp指向的第一个重复元素所在的位置。通过while循环去重，去重后，temp指向的是重复元素中的最后一个位置。最后cur.next = temp.next就实现了消除重复元素。当然，如果为发现重复元素，则直接向后迭代即可。

## 从链表中删去总和值为零的连续节点

### 题目

给你一个链表的头节点 head，请你编写代码，反复删去链表中由 总和 值为 0 的连续节点组成的序列，直到不存在这样的序列为止。

删除完毕后，请你返回最终结果链表的头节点。

你可以返回任何满足题目要求的答案。

（注意，下面示例中的所有序列，都是对 ListNode 对象序列化的表示。）

```c++
示例 1：

输入：head = [1,2,-3,3,1]
输出：[3,1]
提示：答案 [1,2,1] 也是正确的。
示例 2：

输入：head = [1,2,3,-3,4]
输出：[1,2,4]
示例 3：

输入：head = [1,2,3,-3,-2]
输出：[1]
```

### 题解

```c++
class Solution {
public:
    ListNode* removeZeroSumSublists(ListNode* head) {
        if (head == NULL) {
            return head;
        }
        unordered_map<int, ListNode *> prefixSum;
      	// 有可能删除头节点，所以构造头节点
        ListNode *newHead = new ListNode(0);
        newHead->next = head;
        ListNode *p = newHead;
        int cur = 0, tempCur = 0;
        while (p != NULL) {
            cur += p->val;
          	// 如果在prefixSum中找到对应key
            if (prefixSum.find(cur) != prefixSum.end()) {
              	// 删除连续和为0的所有节点
                ListNode *temp = prefixSum[cur]->next;
                prefixSum[cur]->next = p->next;
                tempCur = cur;
              	// 从map中删除对应的前缀和
                while (temp != p) {
                    tempCur += temp->val;
                    prefixSum.erase(tempCur);
                    temp = temp->next;
                }
            } else { // 如果在prefixSum中未找到对应key
                prefixSum[cur] = p;
            }
            p = p->next;
        }
        return newHead->next;
    }
};
```

### 总结

- 对于前缀和相同的项，那他们中间的部分即是可以消除掉的，比如以 [1, 2, 3, -3, 4] 为例，其前缀和数组为 [1, 3, 6, 3, 7] ，我们发现有两项均为 3，则 6 和 第二个 3 所对应的原数组中的数字是可以消掉的。换成链表其实也是一样的思路，把第一个 3 的 next 指向第二个 3 的 next 即可


## 分割链表

### 题目

给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。

你应当保留两个分区中每个节点的初始相对位置。

```c++
示例:

输入: head = 1->4->3->2->5->2, x = 3
输出: 1->2->2->4->3->5
```

### 题解

```c++
class Solution {
public:
    ListNode* partition(ListNode* head, int x) {
        if (head == NULL) {
            return head;
        }
        ListNode *cur = head, *beforHead = new ListNode(0), *befor = beforHead, *afterHead = new ListNode(0), *after = afterHead;
        while (cur != NULL) {
            if (cur->val < x) {
                befor->next = cur;
                befor = befor->next;
            } else {
                after->next = cur;
                after = after->next;
            }
            cur = cur->next;
        }
      	// 此时after->next指向该链表中某一个节点，如果不把after->next指向空，就会形成环状链表
        after->next = NULL;
        befor->next = afterHead->next;
        return beforHead->next;
    }
};
```

### 总结

- 把一条链表分割成两份时
  - 如果头节点明确知道分配给哪条链表，就不需要构建哑节点，
  - 如果头节点不知道具体分配给哪条链表，需要构建两个哑节点，可以避免头节点分配的判断

- 分割链表需要两个头指针不动，两个指针进行迭代，给头指针后面添加节点

## 反转链表II

### 题目

反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。

说明:
1 ≤ m ≤ n ≤ 链表长度。

```c++
示例:

输入: 1->2->3->4->5->NULL, m = 2, n = 4
输出: 1->4->3->2->5->NULL
```

### 题解

```c++
class Solution {
public:
    ListNode* reverseBetween(ListNode* head, int m, int n) {
        if (head == NULL) {
            return head;
        }
        ListNode *cur = head, *pre = NULL;
        while (m > 1) {
            pre = cur;
            cur = cur->next;
            m--;
            n--;
        }
        ListNode *node = pre, *tail = cur;
      	// 进行翻转
        while (n > 0) {
            ListNode *temp = cur->next;
            cur->next = pre;
            pre = cur;
            cur = temp;
            n--;
        }
      	// 如果只有一个节点，此时node==NULL，需要额外进行判断
        if (node == NULL) {
            head = pre;
        } else {
            node->next = pre;
        }
        tail->next = cur;
        return head;
    }
};
```

### 总结

- 先移动到m点，然后把m-n之间的节点进行翻转
- 记录m点前一个节点，用来连接反转后的链表头节点，记录m点的节点，该节点是反转后链表的尾节点

# 困难

<<<<<<< HEAD
## K个一组反转链表

### 题目

给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。

k 是一个正整数，它的值小于或等于链表的长度。

如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。

```c++
示例：

给你这个链表：1->2->3->4->5

当 k = 2 时，应当返回: 2->1->4->3->5

当 k = 3 时，应当返回: 3->2->1->4->5
```

### 题解

```c++
class Solution {
public:
  	// 翻转一个子链表，并且返回新的头与尾
    pair<ListNode*, ListNode*> myReverse(ListNode* head, ListNode* tail) {
        ListNode *pre = NULL, *cur = head;
        tail->next = NULL;
        while (cur != NULL) {
            ListNode *next = cur->next;
            cur->next = pre;
            pre = cur;
            cur = next;
        }
        return {tail, head};
    }

    ListNode* reverseKGroup(ListNode* head, int k) {
        if (head == NULL) {
            return head;
        }
        ListNode *newHead = new ListNode(0);
        newHead->next = head;
        ListNode *pre = newHead;
      
        while (head != NULL) {
            ListNode *tail = head;
          	// 查看剩余部分长度是否大于等于 k
          	// 如果大于k接着翻转，否则直接返回该链表
            for (int i = 1; i < k; i++) {
                tail = tail->next;
                if (tail == NULL) {
                    return newHead->next;
                }
            }
            ListNode *next = tail->next;

            pair<ListNode*, ListNode*> result = myReverse(head, tail);
          	// 把子链表重新接回原链表
            pre->next = result.first;
            result.second->next = next;
          	// 移动head和pre的位置
            pre = result.second;
            head = result.second->next;
        }
        return newHead->next;
    }
};
```

### 总结

- 如果没有哑节点翻转第一个节点需要特殊判断、返回链表的头节点也需要特别判断
  - 链表翻转之后，链表的头结点发生了变化，那么应该返回哪个结点呢？照理来说，前 k 个结点翻转之后，链表的头结点应该是第 k 个结点。那么要在遍历过程中记录第 k 个结点吗？但是如果链表里面没有 k 个结点，答案又还是原来的头结点。


- 在翻转子链表的时候，我们不仅需要子链表头结点 `head`，还需要有 `head` 的上一个结点 `pre`，以便翻转完后把子链表再接回 `pre`
- 我们还需要反转子链表的下一个节点`next`，以便上个子链表翻转完成后，再把后面链表给接上
=======
>>>>>>> fb27a73ae5c30a9f2e2ccc01858ecb9cec6d3313
