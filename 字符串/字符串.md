[toc]

# 字符串

# 简单

## 翻转字符串的单词II

### 题目

给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。

```c++
示例 1:

输入: "Let's take LeetCode contest"
输出: "s'teL ekat edoCteeL tsetnoc" 
注意：在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。
```

### 题解

```c++
class Solution {
public:
    void reverseRang(string& s, int left, int right) {
        if (left > right || right > s.size()) {
            return;
        }
        while (left < right) {
            char temp = s[left];
            s[left] = s[right];
            s[right] = temp;
            left++;
            right--;
        }
    }

    string reverseWords(string s) {
        int first_index = 0;
        for (int i = 0; i < s.size(); i++) {
            if (s[i] == ' ') {
                reverseRang(s, first_index, i - 1);
                first_index = i + 1;
            }
            if (i == s.size() - 1) {
                reverseRang(s, first_index, i);
            }
        }
        return s;
    }
};
```

### 总结

- 使用双指针，把空格前的字符进行翻转

## 最后一个单词的长度

### 题目

给定一个仅包含大小写字母和空格 ' ' 的字符串 s，返回其最后一个单词的长度。如果字符串从左向右滚动显示，那么最后一个单词就是最后出现的单词。

如果不存在最后一个单词，请返回 0 。

说明：一个单词是指仅由字母组成、不包含任何空格字符的 最大子字符串。

```c++
示例:

输入: "Hello World"
输出: 5
```

### 题解

```c++
class Solution {
public:
    int lengthOfLastWord(string s) {
        int count = 0;
        for (int i = s.size() - 1; i >=0; i--) {
            if (s[i] == ' ') {
                if (count == 0) {
                    continue;
                } else {
                    break;
                }
            }
            count++;
        }
        return count;
    }
};
```

### 总结

- 从右向左遍历，从第一个不是空格的字符开始计数，一旦开始计数，再遇到空格就结束了

## 转换成小写字母

### 题目

实现函数 ToLowerCase()，该函数接收一个字符串参数 str，并将该字符串中的大写字母转换成小写字母，之后返回新的字符串。

```c++
示例 1：

输入: "Hello"
输出: "hello"
示例 2：

输入: "here"
输出: "here"
示例 3：

输入: "LOVELY"
输出: "lovely"
```

### 题解

```c++
class Solution {
public:
    string toLowerCase(string str) {
        string res = "";
        for (int i = 0; i < str.size(); i++) {
            if (str[i] >= 'A' && str[i] <= 'Z') {
                res.append(1, str[i] + 32);
            } else {
                res.append(1, str[i]);
            }
        }
        return res;
    }
};
```

### 总结

- 大写变小写+32，小写变大写-32

## 最长特殊序列I

### 题目

给你两个字符串，请你从这两个字符串中找出最长的特殊序列。

「最长特殊序列」定义如下：该序列为某字符串独有的最长子序列（即不能是其他字符串的子序列）。

子序列 可以通过删去字符串中的某些字符实现，但不能改变剩余字符的相对顺序。空序列为所有字符串的子序列，任何字符串为其自身的子序列。

输入为两个字符串，输出最长特殊序列的长度。如果不存在，则返回 -1。

```c++
示例 1：

输入: "aba", "cdc"
输出: 3
解释: 最长特殊序列可为 "aba" (或 "cdc")，两者均为自身的子序列且不是对方的子序列。
示例 2：

输入：a = "aaa", b = "bbb"
输出：3
示例 3：

输入：a = "aaa", b = "aaa"
输出：-1
```

### 题解

```c++
class Solution {
public:
    int findLUSlength(string a, string b) {
        if (a == b) {
            return -1;
        }
        return a.size() > b.size() ? a.size() : b.size();
    }
};
```

### 总结

## 字符串相加

### 题目

给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。

注意：

num1 和num2 的长度都小于 5100.
num1 和num2 都只包含数字 0-9.
num1 和num2 都不包含任何前导零。
你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式。

### 题解

```c++
class Solution {
public:
    string addStrings(string num1, string num2) {
        string res;
        int i = num1.size() - 1, j = num2.size() - 1, carry = 0;
        while (i >= 0 || j >= 0) {
            int x = i >= 0 ? num1[i] - '0' : 0;
            int y = j >= 0 ? num2[j] - '0' : 0;
            int sum = carry + x + y;
            carry = sum / 10;
            res.append(to_string(sum % 10));
            i--;
            j--;
        }
        if (carry > 0) {
            res.append(1, '1');
        }
        reverse(res.begin(), res.end());
        return res;
    }
};
```

### 总结

## 仅仅反转字母

### 题目

给定一个字符串 S，返回 “反转后的” 字符串，其中不是字母的字符都保留在原地，而所有字母的位置发生反转。

```c++
示例 1：

输入："ab-cd"
输出："dc-ba"
示例 2：

输入："a-bC-dEf-ghIj"
输出："j-Ih-gfE-dCba"
示例 3：

输入："Test1ng-Leet=code-Q!"
输出："Qedo1ct-eeLg=ntse-T!"
```

### 题解

```c++
class Solution {
public:
    string reverseOnlyLetters(string S) {
        int i = 0, j = S.size() - 1;
        while (i < j) {
            if (isalpha(S[i]) && isalpha(S[j])) {
                int temp = S[i];
                S[i] = S[j];
                S[j] = temp;
                i++;
                j--;
            } else if (!isalpha(S[i])) {
                i++;
            } else if (!isalpha(S[j])) {
                j--;
            }
        }
        return S;
    }
};
```

### 总结

- 因为是仅仅反转字母，如果不是字母就不反转，所以需要对字符进行判断

## 气球的最大数量

### 题目

给你一个字符串 text，你需要使用 text 中的字母来拼凑尽可能多的单词 "balloon"（气球）。

字符串 text 中的每个字母最多只能被使用一次。请你返回最多可以拼凑出多少个单词 "balloon"。

```c++
示例 1：

输入：text = "nlaebolko"
输出：1
```

### 题解

```c++
class Solution {
public:
    int maxNumberOfBalloons(string text) {
        vector<int> arr(26);
        for (int i = 0; i < text.size(); i++) {
            arr[text[i] - 'a']++;
        }
        arr['l' - 'a'] /= 2;
        arr['o' - 'a'] /= 2;
        int min = INT_MAX;
        string a = "balon";
        for (int i = 0; i < a.size(); i++) {
            if (arr[a[i] - 'a'] < min) {
                min = arr[a[i] - 'a'];
            }
        }
        return min;
    }
};
```

### 总结

- 用数组统计text中出现元素的数量，然后由于l和o两个字符都是两个，需要把数量除以2
- 然后在遍历过程中，寻找出现次数最小的字符，就是ballon出现最小次数

## 最长公共前缀

### 题目

编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 ""。

```c++
示例 1:

输入: ["flower","flow","flight"]
输出: "fl"
示例 2:

输入: ["dog","racecar","car"]
输出: ""
解释: 输入不存在公共前缀。
```

### 题解

```c++
class Solution {
public:
    string longestCommonPrefix(vector<string>& strs) {
        if(strs.size() == 0) {
            return string();
        } else if(strs.size() == 1) {
            return strs[0];
        }
        string result = "";
        for(int i = 0; i < strs[0].size(); i++) {
            for(int j = 1; j < strs.size(); j++) {
                if(strs[0][i] != strs[j][i]) {
                    return result;
                }
            }
            result += strs[0][i];
        }
        return result;
    }
};

class Solution {
private:
    bool isCommonPrefix(vector<string>& strs, int len) {
        for (int i = 0; i < len; i++) {
            for (int j = 1; j < strs.size(); j++) {
                if (strs[0][i] != strs[j][i]) {
                    return false;
                }
            }
        }
        return true;
    }
    
public:
    string longestCommonPrefix(vector<string>& strs) {
        if(strs.size() == 0) {
            return string();
        } else if(strs.size() == 1) {
            return strs[0];
        }
        int minLen = INT_MAX;
        for (string s : strs) {
            minLen = min(minLen, int(s.size()));
        }
        int left = 0, right = minLen;
        while (left <= right) {
            int mid = (left + right) / 2;
            if (isCommonPrefix(strs, mid)) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return strs[0].substr(0, (left + right) / 2);
    }
};
```

### 总结

- 选取第一个字符串作为标准，然后遍历这个字符串
- 对应这个字符串的index，然后遍历整个strs对应index的字符，如果符合继续遍历，否则则返回